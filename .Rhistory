################################################################################
#               INSTALAÇÃO E CARREGAMENTO DE PACOTES NECESSÁRIOS               #
################################################################################
#Pacotes utilizados
pacotes <- c("plotly","tidyverse","knitr","kableExtra","reshape2","ggrepel",
"fastDummies","lmtest","splines","jtools","questionr","MASS",
"pscl","overdisp","magick","cowplot","beepr")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
################################################################################
#               INSTALAÇÃO E CARREGAMENTO DE PACOTES NECESSÁRIOS               #
################################################################################
#Pacotes utilizados
pacotes <- c("plotly","tidyverse","knitr","kableExtra","reshape2","ggrepel",
"fastDummies","lmtest","splines","jtools","questionr","MASS",
"pscl","overdisp","magick","cowplot","beepr")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
################################################################################
#               INSTALAÇÃO E CARREGAMENTO DE PACOTES NECESSÁRIOS               #
################################################################################
#Pacotes utilizados
pacotes <- c("plotly",
"tidyverse",
"knitr",
"kableExtra",
"reshape2",
"ggrepel",
"fastDummies",
"lmtest",
"splines",
"jtools",
"questionr",
"MASS",
"pscl",
"overdisp",
"magick",
"cowplot",
"beepr")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
load(file = "corruption.RData")
# Comportamento das variáveis 'corruption' e 'violations' antes e depois do
# início da vigência da lei
corruption %>%
mutate(lnviolations = log(violations),
lnviolations = ifelse(lnviolations == -Inf,
yes = 0,
no = lnviolations)) %>%
ggplot(aes(x = corruption, y = lnviolations)) +
geom_point(color = "black") +
geom_smooth(aes(color = "Fitted Values"),
method = "lm",
formula = y ~ splines::bs(x),
se = FALSE, size = 2) +
geom_text_repel(aes(label = code), # pacote ggrepel
size = 2,
color = "black",
max.overlaps = 100) +
labs(y = "Violações de Trânsito em NY (logs)",
x = "Índice de Corrupção dos Países") +
scale_color_manual("Label:",
values = "gold") +
facet_wrap(~post) +
theme_bw()
################################################################################
#                        ESTIMAÇÃO DO MODELO POISSON                           #
################################################################################
# Estimação do modelo
modelo_poisson <- glm(formula = violations ~ staff + post + corruption,
data = corruption,
family = "poisson")
# Parâmetros do modelo_poisson
summary(modelo_poisson)
# Extração do valor de Log-Likelihood (LL)
logLik(modelo_poisson)
# Outra forma de visualização dos parâmetros - função summ do pacote jtools
summ(modelo_poisson, digits = 4, confint = T, ci.width = 0.95)
export_summs(modelo_poisson, scale = F, digits = 4)
# Outra forma de visualização dos parâmetros - função summ do pacote jtools
summ(modelo_poisson, digits = 4, confint = T, ci.width = 0.95)
modelo_poisson0 <- glm(formula = violations ~ 1,
data = corruption,
family = "poisson")
summ(modelo_poisson0)
logLik(modelo_poisson0)
summ(modelo_poisson)
logLik(modelo_poisson)
-2*(logLik(modelo_poisson0)-logLik(modelo_poisson))
chi2 <- -2*(logLik(modelo_poisson0)-logLik(modelo_poisson))
chi2
delta_AIC <- 6899.30 - 4151.59
delta_AIC
chi2 - 2*(3)
delta_AIC <- 6899.30 - 4151.59
delta_AIC
modelo_poisson
# LR Test - função lrtest do pacote lmtest
#(likelihood ratio test para comparação de LL's entre modelos)
lrtest(modelo_poisson) #no caso, comparação com modelo nulo (somente com intercepto)
modelo_poisson$fitted.values
# Adicionando os fitted values do modelo Poisson (lambda_poisson) à base de dados:
corruption$lambda_poisson <- modelo_poisson$fitted.values
# Criando a nova variável Y*:
attach(corruption)
corruption$ystar <- (((violations - lambda_poisson) ^ 2)
- violations) / lambda_poisson
detach(corruption)
ystar
corruption$ystar
# Estimando o modelo auxiliar OLS, sem o intercepto:
modelo_auxiliar <- lm(formula = ystar ~ 0 + lambda_poisson,
data = corruption)
# Observando os parâmetros do modelo_auxiliar
summary(modelo_auxiliar)
# Uma abordagem mais direta para a detecção da superdispersão pelo Teste de
# Cameron e Trivedi (1990) é por meio da utilização do algoritmo overdisp().
# Função overdisp do pacote overdisp
overdisp(x = corruption,
dependent.position = 3,
predictor.position = 4:6)
# Uma abordagem mais direta para a detecção da superdispersão pelo Teste de
# Cameron e Trivedi (1990) é por meio da utilização do algoritmo overdisp().
# Função overdisp do pacote overdisp
overdisp(x = corruption,
dependent.position = 3,
predictor.position = 4:6)
# Apenas para fins didáticos, caso considerássemos a estimação Poisson como a
# mais adequada, qual seria a quantidade média esperada de violações de trânsito
# para um país cujo corpo diplomático fosse composto por 23 membros, considerando
# o período anterior à vigência da lei e cujo índice de corrupção seja
# igual a 0.5?
predict(object = modelo_poisson,
newdata = data.frame(staff = 23,
post = "no",
corruption = 0.5),
type = "response")
# Qual seria a quantidade média esperada de violações de trânsito para o mesmo
# país, porém agora considerando a vigência da lei?
predict(object = modelo_poisson,
newdata = data.frame(staff = 23,
post = "yes",
corruption = 0.5),
type = "response")
# Uma abordagem mais direta para a detecção da superdispersão pelo Teste de
# Cameron e Trivedi (1990) é por meio da utilização do algoritmo overdisp().
# Função overdisp do pacote overdisp
overdisp(x = corruption,
dependent.position = 3,
predictor.position = 4:6)
# Apenas para fins didáticos, caso considerássemos a estimação Poisson como a
# mais adequada, qual seria a quantidade média esperada de violações de trânsito
# para um país cujo corpo diplomático fosse composto por 23 membros, considerando
# o período anterior à vigência da lei e cujo índice de corrupção seja
# igual a 0.5?
predict(object = modelo_poisson,
newdata = data.frame(staff = 23,
post = "no",
corruption = 0.5),
type = "response")
# Qual seria a quantidade média esperada de violações de trânsito para o mesmo
# país, porém agora considerando a vigência da lei?
predict(object = modelo_poisson,
newdata = data.frame(staff = 23,
post = "yes",
corruption = 0.5),
type = "response")
?overdisp
